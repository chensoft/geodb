use std::sync::LazyLock;

use serde::{Serialize, Deserialize};
use anyhow::Result;
use indexmap::IndexMap;
use handlebars::Handlebars;

#[derive(Debug, Default, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct Subdivision {
    /// e.g., "CN-SH"
    pub code: String,

    /// e.g., "CN"
    pub country: String,

    /// e.g., "Municipality"
    pub category: String,

    /// e.g., ""
    pub parent: String,

    /// e.g., "Shanghai"
    pub name: String,

    /// e.g., "上海市"
    pub native: String,
}

pub static SUBDIVISIONS: LazyLock<IndexMap<String, Subdivision>> = LazyLock::new(|| {
    let mut csv = csv::Reader::from_path("res/subdivision.csv").expect("missing subdivision file");
    let mut map = IndexMap::new();

    for val in csv.deserialize() {
        let val: Subdivision = val.expect("parse subdivision failed");
        map.insert(val.code.clone(), val);
    }

    map
});

pub fn generate() -> Result<()> {
    handlebars_helper!(code: |v: String| {
        v.replace("-", "_")
    });

    handlebars_helper!(parent: |v: String| {
        match v.is_empty() {
            true => "None".to_string(),
            false => format!("Some(Self::{})", v.replace("-", "_")),
        }
    });

    let subdivisions: Vec<Subdivision> = SUBDIVISIONS.values().cloned().collect();

    let mut template = Handlebars::new();
    template.register_helper("code", Box::new(code));
    template.register_helper("parent", Box::new(parent));
    template.register_template_string("default", r#"// !!!DO NOT EDIT THIS FILE!!! //
#![allow(non_camel_case_types)]

/// Subdivision
#[derive(Debug, Clone, Copy, Hash, Eq, PartialEq, Ord, PartialOrd, Serialize, Deserialize, EnumIter)]
pub enum Subdivision {
{{#each subdivisions}}
    {{code this.code}},
{{/each}}
}

impl Subdivision {
    /// Get subdivision from code
    pub fn from_code(code: &str) -> Option<Self> {
        match code {
{{#each subdivisions}}
            "{{this.code}}" => Some(Self::{{code this.code}}),
{{/each}}
            _ => None,
        }
    }

    /// Subdivision code
    pub const fn code(&self) -> &'static str {
        match self {
{{#each subdivisions}}
            Self::{{code this.code}} => "{{this.code}}",
{{/each}}
        }
    }

    /// Country code
    pub const fn country(&self) -> crate::Country {
        match self {
{{#each subdivisions}}
            Self::{{code this.code}} => crate::Country::{{this.country}},
{{/each}}
        }
    }

    /// Subdivision category
    pub const fn category(&self) -> &'static str {
        match self {
{{#each subdivisions}}
            Self::{{code this.code}} => "{{this.category}}",
{{/each}}
        }
    }

    /// Subdivision parent subdivision
    pub const fn parent(&self) -> Option<Self> {
        match self {
{{#each subdivisions}}
            Self::{{code this.code}} => {{parent this.parent}},
{{/each}}
        }
    }

    /// Subdivision english name
    pub const fn name(&self) -> &'static str {
        match self {
{{#each subdivisions}}
            Self::{{code this.code}} => "{{this.name}}",
{{/each}}
        }
    }

    /// Subdivision native name
    pub const fn native(&self) -> &'static str {
        match self {
{{#each subdivisions}}
            Self::{{code this.code}} => "{{this.native}}",
{{/each}}
        }
    }
}"#)?;

    std::fs::write("src/subdivision.rs", template.render("default", &indexmap! { "subdivisions" => subdivisions})?)?;

    Ok(())
}